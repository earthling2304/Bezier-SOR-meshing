//#include <OpenGL/glu.h>
//#include <OpenGL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
#include<fstream>
#define STEPS 1000
#define PI 3.14159265358979323846
using namespace std;
struct sample{
	int x, y,z;
};

class Vec{ /** class Vec defines a vector- instantiated to keep track of the basis vectors at point where camera is located */
public:
  float x,y,z;
  void set(float a, float b, float c){
    x = a;
    y = b;
    z = c;
  }
 float dot(Vec v){
    return (x*v.x + y*v.y + z*v.z);
  }

};

class Point{ /** class Point defines a point vector; instantiated to keep track of the point where the camera is located*/
public:
  float x,y,z;
  float dot(Vec v){
    return (x*v.x + y*v.y + z*v.z);
  }

};

struct sample s[101];
/* Define a global array of x and y, the coords of control points */
int arrx[20]; //Let's assume there are 20 points max, for now.
int arry[20];
int i = 0; //keeping count of the number of ctrl pts chosen so far
int num; //total no of ctrl pts
char key;
int remx, remy;
int dragx, dragy;	
int dragindex;
void Mouse(int button, int state, int x, int y);
void mousedel(int button, int state, int x, int y);
int rot[3][3] = {{1,0,0,0},{0,1,0,0},{0,0,1,0}};
int rotaxis[3];
int angle_increment = 90;
int Trans1
float Bezier(int *arr, int i, int j, float t){

/*Recursive de Casteljau's algorithm to find the points on the Bezier curve*/ 
    if(j == 0)
        return arr[i];
    return Bezier(arr, i, j-1, t)*(1-t)+ t*Bezier(arr, i+1,j-1, t);
}

/*

 void roll(const float angle){ /**Function to rotate about n by angle given as an argument
    float Cos = cos(angle*PI/180); ///convert to radians and take cosine
    float Sin = sin(angle*PI/180); ///convert to radians and take sine
    Vec p = u;
    u.set(p.x*Cos - v.x*Sin, p.y*Cos - v.y*Sin, p.z*Cos - v.z*Sin);
    Vec q = v;
    v.set(p.x*Sin + q.x*Cos,p.y*Sin + q.y*Cos,p.z*Sin + q.z*Cos );
    setM();
}
    void yaw(const float angle){ /**Function to rotate about v by angle given as an argument
    
    float Cos = cos(angle*PI/180); ///convert to radians and take cosine
    float Sin = sin(angle*PI/180); ///convert to radians and take cosine
    Vec p = u;
    u.set(p.x*Cos + n.x*Sin, p.y*Cos + n.y*Sin, p.z*Cos+n.z*Sin);
    Vec q = n;
    n.set(-p.x*Sin + q.x*Cos,-p.y*Sin + q.y*Cos,-p.z*Sin + q.z*Cos);
    setM();
}

*/



void createOff(){
	int vertices = 398, faces = 400, edges= 400;
	ofstream outfile;
	ifstream infile;
	outfile.open("SOR.off", ios::out);
	outfile<<"OFF"<<endl;
	outfile<<vertices<<" "<<faces<<" "<<edges<<endl;
	int j;
	for(j=0;j<101;j++){
		outfile<<s[j].x<<" "<<s[j].y<<" "<<s[j].z<<endl;
	}
	rotaxis[0] = s[100].x - s[0].x;
	rotaxis[1] = s[100].y - s[0].y;
	rotaxis[2] = s[100].z - s[0].z;
	float rollangle = (PI/2)-atan((float)rotaxis[1]/(float)rotaxis[0]);

	//cout<<rollangle<<endl;
	outfile.close();

}

void printToFile(){
	ofstream outfile;
	int j;
	outfile.open("sor.csv", ios::out);
	for(j=0;j<101;j++){
		outfile<<s[j].x<<","<<s[j].y<<endl;		
	}
	 

	outfile.close();
}

void searchndelete(){ 
	int c,j;
	for(c=0;c<num;c++){
			if(remx < (arrx[c]+5) && remx > (arrx[c]-5)&& remy < (arry[c]+5) && remy>(arry[c]-5)){//shift
				for(j = c;j<num-1;j++){
					arrx[j] = arrx[j+1];
					arry[j] = arry[j+1];
					cout<<"Deleted one point"<<endl;
				}
				num--;
				i--;
				//return 0; //found and deleted
			}
	}
	
	//return 0; //not found so no deletion.

}

int search(int x, int y){
	int ret = 0;
	int c,j;
	for(c=0;c<num;c++){
		if(x < (arrx[c]+5) && x >(arrx[c]-5) && y<(arry[c]+5) &&y> arry[c]-5){
			dragindex = c;
			return 1;
		}
	}
	return 0;
}

void drawCurve(){
	int k, X, Y;
	float t;
	glClear(GL_COLOR_BUFFER_BIT);
	for(k=0;k<num;k++){
		glPointSize(8);
		glColor3f(1,0,0);
		glBegin(GL_POINTS);
		glVertex2i(arrx[k], arry[k]);
		glEnd();
		glPointSize(5);	
	}
	for(k=0;k<=STEPS;k++){
		t = float(k)/(float)STEPS;
		X = Bezier(arrx, 0, num-1, t);			
		Y = Bezier(arry, 0, num-1, t);
		if(k%10==0){
			s[k/10].x = X;
			s[k/10].y = Y;
			s[k/10].z = 0;
		}
		s[100].x=X;
		s[100].y = Y;
		//cout<<X<<" "<<Y<<endl; //Seems to be working.
		//glPointSize(3); 				//Setting the point size to 3
		glColor3f(0, 0, 1); 
		glBegin(GL_POINTS);
        	glVertex2i(X, Y);
       		glEnd();		
		}
	
}


void Display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

void drag(int x, int y){
	int yy = glutGet(GLUT_WINDOW_HEIGHT);
	arrx[dragindex] = x;
	arry[dragindex] = yy-y;
	drawCurve();
	glutSwapBuffers();

}

void Keyboard(unsigned char k,int x, int y){
	key = k;
	if(k == 'd' && i == num){ 
		drawCurve();
		glutSwapBuffers();		
		}
	if(k == 'a' && i == num){
		num++;
		//i++;
		glutMouseFunc(Mouse);
			
	}
	if(k == 'r' && i == num){
		//glutMouseFunc(mousedel);
		
		glutMouseFunc(Mouse);
			
	}
	if(k == 'm' && i==num){
		glutMouseFunc(Mouse);

	}
	//cout<<k<<endl;
}


void Mouse(int button, int state, int x, int y)
{
    int yy;
    yy = glutGet(GLUT_WINDOW_HEIGHT);
    int xx = glutGet(GLUT_WINDOW_WIDTH);
    //cout<<xx<<endl;
    //cout<<yy<<endl;
    y = yy - y; /* In Glut, Y coordinate increases from top to bottom */
    glColor3f(1.0, 0, 0);
	if((i<num)&&(button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN)){
   		cout<<x<<" "<<y<<endl;
    	
        	glBegin(GL_POINTS);
        	glVertex2i(x, y);
        	glEnd();
    	
		arrx[i] = x;
		arry[i] = y;
		i++;
    glutSwapBuffers();
	}
	if(i == num && key == 'r') {
		cout<<"Point to be deleted:"<<x<<" "<<y<<endl;
		remx = x;
		remy = y;
		searchndelete();
	}
	if(i==num && key == 'm'){
		if(search(x,y))
			glutMotionFunc(drag);;
	}

	if(i==num && key =='s'){ //Surface of revolution
		createOff();
		//int j;		
		/*for(j=0;j<101;j++){
			cout<<s[j].x<<" "<<s[j].y<<endl;		
		}*/
	}	
	/*if(i==num && key == 'd'){
		drawCurve();
		glFlush();
	}*/
}

void Init(void)
{
    glClearColor(1.0f, 1.0f, 1.0f, 0.0);
    glColor3f(1.0f, 1.0f, 1.0f);
    glPointSize(5.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0, 1309.0, 0.0, 716.0);
}

int main(int argc, char** argv)
{	cout<<"Enter number of points:"<<endl;
	cin>>num;
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(1309, 716);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("Bezier Curve");
    glutDisplayFunc(Display);
	glutKeyboardFunc(Keyboard);    
	glutMouseFunc(Mouse);
	Init();
    glutMainLoop();
}
