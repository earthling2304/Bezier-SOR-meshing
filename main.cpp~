//#include <OpenGL/glu.h>
//#include <OpenGL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
int arrx[20]; //Let's assume there are 20 points max, for now.
int arry[20];
int i = 0; //keeping count of the number of ctrl pts chosen so far
int control; //total no of ctrl pts

float Bezier(int *arr, int i, int j, float t){
    /*Recursive de Casteljau's algorithm to find the points on the Bezier curve*/
    if(j == 0)
        return arr[i];
    return Bezier(arr, i, j-1, t)*(1-t)+ t*Bezier(arr, i+1,j-1, t);
}

void setPixel(GLint x,GLint y){/**
                                This function sets the drawing mode to points, so as to enable pixel by pixel colouring, and sets the pixel specified by the arguments as x and y coordinates.
                                */
    glBegin(GL_POINTS);
    glMatrixMode(GL_PROJECTION);						// Operate on the Projection matrix
    glLoadIdentity();                                   //loads the identitty matrix
    gluPerspective(50.0f, 1, 0.1f, 500.0f);
    glRotatef(12.5,1,0,0);
    glTranslatef(-2, -3, -7);
    glScalef(0.05, 0.05, 0.05);
    glVertex2i(x,y);
    glEnd();
    printf("%d %d\n", x, y);
    //glColor3f(1,1,1);
    glFlush();
}


void mouse(int button, int state, int x, int y){
    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN){
        //We need to draw the point and add it to the control point arrays.
        
        
        if(i<control){
            std::cout<<x<<" "<<y<<std::endl;
            glPointSize(6); 				///Setting the point size to 6
            glColor3f(0, 0, 0); //Points in black
            setPixel(x,y); //draw the point
            
            arrx[i] = x;	//add to the arrays
            arry[i] = y;
        }
        i++;
        if(i == control){
            //Find the points on Bezier and draw
            int k,t, X, Y;
            for(k=0;k<10000;k++){
                t = float(k)/10000;
                X = Bezier(arrx, 0, control-1, t);
                Y = Bezier(arry, 0, control-1, t);
                glPointSize(3); 				///Setting the point size to 3
                glColor3f(1, 0, 0.5); //curve in pink
                setPixel(X,Y);			
            }
        }
    }
    glutPostRedisplay();
}




void background()
{
    glColor3f(0.59, 0.49, 0.99);
    glBegin(GL_QUADS); //Left wall of the bounding box
    glVertex3f(0, 0, 0);
    glVertex3f(0, 80, 0);
    glVertex3f(0, 80, 80);
    glVertex3f(0, 0, 80);
    glEnd();
    
    glBegin(GL_QUADS); //Right wall of the bounding box
    glVertex3f(80, 0, 0);
    glVertex3f(80, 80, 0);
    glVertex3f(80, 80, 80);
    glVertex3f(80, 0, 80);
    glEnd();
    
    glBegin(GL_QUADS); //Back wall of the bounding box
    glColor3f(0.627, 0.904, 0.976);
    glVertex3f(0, 0, 0);
    glVertex3f(80, 0, 0);
    glVertex3f(80, 80, 0);
    glVertex3f(0, 80, 0);
    glEnd();
    
    glPointSize(5);
    glColor3f(1, 0, 0);
    glBegin(GL_POINTS);
    glVertex3f(0, 0, 0);
    glVertex3f(10, 10, 10);
    glVertex3f(10, 10, 60);
    glVertex3f(80, 80, 10);
    glEnd();
    
    glBegin(GL_QUADS); //Bottom wall of the bounding box
    glColor3f(0.89, 0.79, 0.99);
    glVertex3f(0, 0, 0);
    glVertex3f(80, 0, 0);
    glVertex3f(80, 0, 80);
    glVertex3f(0, 0, 80);
    glEnd();
    
}

void init()
{
    glutInitDisplayMode(GLUT_DEPTH | GLUT_SINGLE | GLUT_RGB);
    //Allocate colour display buffer and depth buffer
    glEnable(GL_DEPTH_TEST);									//Enable depth testing for hidden surface removal
    glDepthMask(GL_TRUE);                   //enable for writing into the depth buffer
    glDepthFunc(GL_LEQUAL);                //for comapring the values
    glDepthRange(0.0f, 1.0f);
    
    glShadeModel(GL_SMOOTH);		// Enable smooth shading
    glClearColor(1, 1, 1, 1.0f);	//Set default clear colour
    glClearDepth(1.0);
}

void display()   //rendering occurs here
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //clear the color and the depth buffer before each rendering occurs
    glPushMatrix();
    glRotatef(12.5,1,0,0);
    glTranslatef(-2, -3, -7);
    glScalef(0.05, 0.05, 0.05);
    glColor3d(0.99,0.83,0);
    background();
    glPopMatrix();
    glutSwapBuffers();         //swaping the current buffer with the back buffer, used in case of double buffers
}

void reshape(GLsizei width, GLsizei height) {
    if (height == 0) height = 1;						// To prevent divide by 0
    GLfloat aspect = (GLfloat)width / (GLfloat)height;	// Set the aspect ratio of the clipping volume to match the viewport
    glViewport(0, 0, width, height);					// Set the viewport to cover the new window
    glMatrixMode(GL_PROJECTION);						// Operate on the Projection matrix
    glLoadIdentity();                                   //loads the identitty matrix
    gluPerspective(50.0f, aspect, 0.1f, 500.0f);        //sets the projection matrix with the view angle to 60, the aspect ratio, the near plane and the far plane.
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();		// Enable perspective projection with fovy, aspect, zNear and zFar
}

static void idle(void)
{
    glutPostRedisplay();    //for calling the main loop to draw again. this enable the motion for the elements.
}

int main(int argc, char **argv)
{
    printf("Enter number of control points\n");
    scanf("%d", &control);
    printf("Please click on the points you would like to choose as control");
    glutInit(&argc, argv);  ///configuration and opening
    glutInitWindowSize(1000,1000);
    glutCreateWindow("Bezier curves");
    init();    ///sets opengl States and variables
    glutDisplayFunc(display);
    glutReshapeFunc(reshape); ///function for resizing the window
    glutIdleFunc(idle);
    glutMouseFunc(mouse); ///handle keyboard events
    glutMainLoop();  ///entr event driven loop
    return 0;
}

