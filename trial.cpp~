//#include <OpenGL/glu.h>
//#include <OpenGL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
#include<fstream>
#include"Camera.h"
#define STEPS 1000
#define PI 3.14159265358979323846
#define SIDES 4
#define INC 2
using namespace std;
struct sample{
	int x, y,z,w;
};


struct sample s[INC+1];
/* Define a global array of x and y, the coords of control points */
int arrx[20]; //Let's assume there are 20 points max, for now.
int arry[20];
int i = 0; //keeping count of the number of ctrl pts chosen so far
int num; //total no of ctrl pts
char key;
int remx, remy;
int dragx, dragy;	
int dragindex;
void Mouse(int button, int state, int x, int y);
void mousedel(int button, int state, int x, int y);
int rotaxis[4];
int angle_increment = 2*PI/SIDES;
void drawCurve();



//Camera cam1;



float Bezier(int *arr, int i, int j, float t){

/*Recursive de Casteljau's algorithm to find the points on the Bezier curve*/ 
    if(j == 0)
        return arr[i];
    return Bezier(arr, i, j-1, t)*(1-t)+ t*Bezier(arr, i+1,j-1, t);
}


void createOff(){
	Camera cam;
	drawCurve();
	int vertices = (INC+1)*SIDES;
	int faces = INC*SIDES;
	int edges= SIDES*INC;
	ofstream outfile;
	ifstream infile;
	outfile.open("SOR.off", ios::out);
	outfile<<"OFF"<<endl;
	outfile<<vertices<<" "<<faces<<" "<<edges<<endl;
	int j;
	for(j=0;j<(INC+1);j++){
		outfile<<s[j].x<<" "<<s[j].y<<" "<<s[j].z<<endl;
	}
	rotaxis[0] = s[INC].x - s[0].x;
	rotaxis[1] = s[INC].y - s[0].y;
	rotaxis[2] = s[INC].z - s[0].z;
	rotaxis[3] = 0;
	float rollangle = (PI/2)-atan((float)rotaxis[1]/(float)rotaxis[0]);
	cam.translate(s[0].x-cam.eye.x, s[0].y-cam.eye.y, s[0].z-cam.eye.z);
	cam.roll(rollangle);
	int t;	
	int tempx,tempy, tempz;
	for(j = 1;j<SIDES;j++){
		cam.yaw(angle_increment);
		for(t=0;t<(INC+1);t++){
			s[t].x = cam.M[0][0]*s[t].x+cam.M[0][1]*s[t].y+cam.M[0][2]*s[t].z+ cam.M[0][3]*s[t].w;
			s[t].y = cam.M[1][0]*s[t].x+cam.M[1][1]*s[t].y+cam.M[1][2]*s[t].z+ cam.M[1][3]*s[t].w;
			s[t].z = cam.M[2][0]*s[t].x+cam.M[2][1]*s[t].y+cam.M[2][2]*s[t].z+ cam.M[2][3]*s[t].w;
			s[t].w = cam.M[3][0]*s[t].x+cam.M[3][1]*s[t].y+cam.M[3][2]*s[t].z+ cam.M[3][3]*s[t].w;
			s[t].x /= s[t].w;
			s[t].y /= s[t].w;
			s[t].z /= s[t].w;
			s[t].w /= s[t].w;
			outfile<<s[t].x<<" "<<s[t].y<<" "<<s[t].z<<endl;	
		}	
	}
	//print the faces 
	//rectangles first?
	int f = 4;
	//int first=1;
	for(t=0;t<SIDES;t++){
		for(j=1;j<(INC-1);j++){
			if(t<(SIDES-1))
				outfile<<f<<" "<<((INC+1)*t)+j<<" "<<((INC+1)*t)+j+1<<" "<<((INC+1)*t)+j+(INC+2)<<" "<<((INC+1)*t)+j+(INC+1)<<endl;
			if(t==(SIDES-1)) 
				outfile<<f<<" "<<((INC+1)*t)+j<<" "<<((INC+1)*t)+j+1<<" "<<(j+(INC+2))%(INC+1)<<" "<<(j+(INC+1))%(INC+1)<<endl;				
		}	
	}
	f=3;
	//int p=0;

	for(t=0;t<SIDES;t++){
		if(t<(SIDES-1)){
			outfile<<f<<" "<<(t*(INC+1))<<" "<<(t*(INC+1))+1<<" "<<(t*(INC+1))+(INC+2)<<endl;
			outfile<<f<<" "<<(t*(INC+1))+(INC-1)<<" "<<(t*(INC+1))+(INC)<<" "<<(t*(INC+1))+(2*INC+1)<<endl;		
			}
		if(t==(SIDES-1)){
			outfile<<f<<" "<<(t*(INC+1))<<" "<<(t*(INC+1))+1<<" "<<((t*(INC+1))+(INC+2))%(INC+1)<<endl;
			outfile<<f<<" "<<(t*(INC+1))+(INC-1)<<" "<<(t*(INC+1))+(INC)<<" "<<((t*(INC+1))+(2*INC+1))%(INC+1)<<endl;
		}
	}

	outfile.close();

}




void printToFile(){
	ofstream outfile;
	int j;
	outfile.open("sor.csv", ios::out);
	for(j=0;j<(INC+1);j++){
		outfile<<s[j].x<<","<<s[j].y<<endl;		
	}
	 

	outfile.close();
}

void searchndelete(){ 
	int c,j;
	for(c=0;c<num;c++){
			if(remx < (arrx[c]+5) && remx > (arrx[c]-5)&& remy < (arry[c]+5) && remy>(arry[c]-5)){//shift
				for(j = c;j<num-1;j++){
					arrx[j] = arrx[j+1];
					arry[j] = arry[j+1];
					cout<<"Deleted one point"<<endl;
				}
				num--;
				i--;
				//return 0; //found and deleted
			}
	}
	
	//return 0; //not found so no deletion.

}

int search(int x, int y){
	int ret = 0;
	int c,j;
	for(c=0;c<num;c++){
		if(x < (arrx[c]+5) && x >(arrx[c]-5) && y<(arry[c]+5) &&y> arry[c]-5){
			dragindex = c;
			return 1;
		}
	}
	return 0;
}

void drawCurve(){
	int k, X, Y;
	float t;
	glClear(GL_COLOR_BUFFER_BIT);
	for(k=0;k<num;k++){
		glPointSize(8);
		glColor3f(1,0,0);
		glBegin(GL_POINTS);
		glVertex2i(arrx[k], arry[k]);
		glEnd();
		glPointSize(5);	
	}
	for(k=0;k<=STEPS;k++){
		t = float(k)/(float)STEPS;
		X = Bezier(arrx, 0, num-1, t);			
		Y = Bezier(arry, 0, num-1, t);
		if(k%(1000/INC)==0){
			s[k/(1000/INC)].x = X;
			s[k/(1000/INC)].y = Y;
			s[k/(1000/INC)].z = 0;
			s[k/(1000/INC)].w = 1;
		}
		s[INC].x=X;
		s[INC].y = Y;
		s[INC].z = 0;
		s[INC].w = 1;
		//cout<<X<<" "<<Y<<endl; //Seems to be working.
		//glPointSize(3); 				//Setting the point size to 3
		glColor3f(0, 0, 1); 
		glBegin(GL_POINTS);
        	glVertex2i(X, Y);
       		glEnd();		
		}
	
}


void Display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

void drag(int x, int y){
	int yy = glutGet(GLUT_WINDOW_HEIGHT);
	arrx[dragindex] = x;
	arry[dragindex] = yy-y;
	drawCurve();
	glutSwapBuffers();

}

void Keyboard(unsigned char k,int x, int y){
	key = k;
	if(k == 'd' && i == num){ 
		drawCurve();
		glutSwapBuffers();		
		}
	if(k == 'a' && i == num){
		num++;
		//i++;
		glutMouseFunc(Mouse);
			
	}
	if(k == 'r' && i == num){
		//glutMouseFunc(mousedel);
		
		glutMouseFunc(Mouse);
			
	}
	if(k == 'm' && i==num){
		glutMouseFunc(Mouse);

	}
	//cout<<k<<endl;
}


void Mouse(int button, int state, int x, int y)
{
    int yy;
    yy = glutGet(GLUT_WINDOW_HEIGHT);
    int xx = glutGet(GLUT_WINDOW_WIDTH);
    //cout<<xx<<endl;
    //cout<<yy<<endl;
    y = yy - y; /* In Glut, Y coordinate increases from top to bottom */
    glColor3f(1.0, 0, 0);
	if((i<num)&&(button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN)){
   		cout<<x<<" "<<y<<endl;
    	
        	glBegin(GL_POINTS);
        	glVertex2i(x, y);
        	glEnd();
    	
		arrx[i] = x;
		arry[i] = y;
		i++;
    glutSwapBuffers();
	}
	if(i == num && key == 'r') {
		cout<<"Point to be deleted:"<<x<<" "<<y<<endl;
		remx = x;
		remy = y;
		searchndelete();
	}
	if(i==num && key == 'm'){
		if(search(x,y))
			glutMotionFunc(drag);;
	}

	if(i==num && key =='s'){ //Surface of revolution
		createOff();
		//int j;		
		/*for(j=0;j<(INC+1);j++){
			cout<<s[j].x<<" "<<s[j].y<<endl;		
		}*/
	}	
	/*if(i==num && key == 'd'){
		drawCurve();
		glFlush();
	}*/
}

void Init(void)
{
    glClearColor(1.0f, 1.0f, 1.0f, 0.0);
    glColor3f(1.0f, 1.0f, 1.0f);
    glPointSize(5.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0, 1309.0, 0.0, 716.0);
}

int main(int argc, char** argv)
{	cout<<"Enter number of points:"<<endl;
	cin>>num;
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(1309, 716);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("Bezier Curve");
    glutDisplayFunc(Display);
	glutKeyboardFunc(Keyboard);    
	glutMouseFunc(Mouse);
	Init();
    glutMainLoop();
}
