//#include <OpenGL/glu.h>
//#include <OpenGL/gl.h>
#include <GL/glut.h>
#include <iostream>
#include <math.h>
#include <stdio.h>
#define STEPS 10000
using namespace std;

/* Define a global array of x and y, the coords of control points */
int arrx[20]; //Let's assume there are 20 points max, for now.
int arry[20];
int i = 0; //keeping count of the number of ctrl pts chosen so far
int num; //total no of ctrl pts
char key;
int remx, remy;
int dragx, dragy;	
int dragindex;
void Mouse(int button, int state, int x, int y);
void mousedel(int button, int state, int x, int y);


float Bezier(int *arr, int i, int j, float t){

/*Recursive de Casteljau's algorithm to find the points on the Bezier curve*/ 
    if(j == 0)
        return arr[i];
    return Bezier(arr, i, j-1, t)*(1-t)+ t*Bezier(arr, i+1,j-1, t);
}

void searchndelete(){ 
	int c,j;
	for(c=0;c<num;c++){
			if(remx < (arrx[c]+5) && remx > (arrx[c]-5)&& remy < (arry[c]+5) && remy>(arry[c]-5)){//shift
				for(j = c;j<num-1;j++){
					arrx[j] = arrx[j+1];
					arry[j] = arry[j+1];
					cout<<"Deleted one point"<<endl;
				}
				num--;
				i--;
				//return 0; //found and deleted
			}
	}
	
	//return 0; //not found so no deletion.

}

int search(int x, int y){
	int ret = 0;
	int c,j;
	for(c=0;c<num;c++){
		if(x < (arrx[c]+5) && x >(arrx[c]-5) && y<(arry[c]+5) &&y> arry[c]-5){
			dragindex = c;
			return 1;
		}
	}
	return 0;
}

void drawCurve(){
	int k, X, Y;
	float t;
	glClear(GL_COLOR_BUFFER_BIT);
	for(k=0;k<num;k++){
		glPointSize(8);
		glColor3f(1,0,0);
		glBegin(GL_POINTS);
		glVertex2i(arrx[k], arry[k]);
		glEnd();
		glPointSize(5);	
	}
	for(k=0;k<=STEPS;k++){
		t = float(k)/(float)STEPS;
		X = Bezier(arrx, 0, num-1, t);			
		Y = Bezier(arry, 0, num-1, t);
		//cout<<X<<" "<<Y<<endl; //Seems to be working.
		//glPointSize(3); 				//Setting the point size to 3
		glColor3f(0, 0, 1); 
		glBegin(GL_POINTS);
        glVertex2i(X, Y);
        glEnd();		
		}
	
}


void Display(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    glFlush();
}

void drag(int x, int y){
	int yy = glutGet(GLUT_WINDOW_HEIGHT);
	arrx[dragindex] = x;
	arry[dragindex] = yy-y;
	drawCurve();
	glutSwapBuffers();

}

void Keyboard(unsigned char k,int x, int y){
	key = k;
	if(k == 'd' && i == num){ 
		drawCurve();
		glutSwapBuffers();		
		}
	if(k == 'a' && i == num){
		num++;
		//i++;
		glutMouseFunc(Mouse);
			
	}
	if(k == 'r' && i == num){
		//glutMouseFunc(mousedel);
		
		glutMouseFunc(Mouse);
			
	}
	if(k == 'm' && i==num){
		glutMouseFunc(Mouse);

	}
	//cout<<k<<endl;
}


void Mouse(int button, int state, int x, int y)
{
    int yy;
    yy = glutGet(GLUT_WINDOW_HEIGHT);
    int xx = glutGet(GLUT_WINDOW_WIDTH);
    //cout<<xx<<endl;
    //cout<<yy<<endl;
    y = yy - y; /* In Glut, Y coordinate increases from top to bottom */
    glColor3f(1.0, 0, 0);
	if((i<num)&&(button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN)){
   		cout<<x<<" "<<y<<endl;
    	
        	glBegin(GL_POINTS);
        	glVertex2i(x, y);
        	glEnd();
    	
		arrx[i] = x;
		arry[i] = y;
		i++;
    glutSwapBuffers();
	}
	if(i == num && key == 'r') {
		cout<<"Point to be deleted:"<<x<<" "<<y<<endl;
		remx = x;
		remy = y;
		searchndelete();
	}
	if(i==num && key == 'm'){
		if(search(x,y))
			glutMotionFunc(drag);;
	}

	
	/*if(i==num && key == 'd'){
		drawCurve();
		glFlush();
	}*/
}

void Init(void)
{
    glClearColor(1.0f, 1.0f, 1.0f, 0.0);
    glColor3f(1.0f, 1.0f, 1.0f);
    glPointSize(5.0);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0.0, 1309.0, 0.0, 716.0);
}

int main(int argc, char** argv)
{	cout<<"Enter number of points:"<<endl;
	cin>>num;
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(1309, 716);
    glutInitWindowPosition(0, 0);
    glutCreateWindow("Bezier Curve");
    glutDisplayFunc(Display);
	glutKeyboardFunc(Keyboard);    
	glutMouseFunc(Mouse);
	Init();
    glutMainLoop();
}
